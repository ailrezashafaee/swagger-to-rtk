/*
 * script builder for swagger into Rtk query structure
 * */
import * as fsPromise from "fs/promises";
import * as path from "path";
import {
  OpenAPIObject,
  OperationObject,
  PathItemObject,
  RequestBodyObject,
  SchemaObject,
} from "openapi3-ts/oas31";

const swaggerFile = path.resolve(__dirname, "./test.json"); //make these a parameter
const OUTPUT_DIR = path.join(__dirname, "./apis");

const readFile = async () => {
  try {
    const returendData = await fsPromise.readFile(swaggerFile, {
      encoding: "utf8",
    });
    return JSON.parse(returendData) as OpenAPIObject;
  } catch (err) {
    console.error(err);
  }
};

// const interfaceBuilder = (name: string) => {};
//
const methodFinder = (method: string) => {
  switch (method) {
    case "get":
      return "query";
    case "post":
      return "mutation";
    case "put":
      return "mutation";
    case "delete":
      return "mutation";
    default:
      return "query";
  }
};

interface endpointReturnType {
  endPointText: string;
  endPointName: string;
  method: string;
  hasParams: boolean;
  methodData: OperationObject;
  description: string;
  responseInterface: string | null;
  requestInterface: string | null;
}
const endPointBuilder = (
  endPointObj: [string, PathItemObject],
  customEndPointName?: string,
): endpointReturnType => {
  const [endPoint, endPointData] = endPointObj;
  const method = Object.keys(endPointData)[0];
  const methodData = Object.values(endPointData)[0] as OperationObject;
  const tag = methodData.tags?.[0];
  const descriptionText = `${methodData.description}`;
  const tailOfEndpoint = endPoint.split("/").reverse()[0];

  const endPointName = customEndPointName
    ? customEndPointName
    : `${tailOfEndpoint}`;

  const hasParams = !!methodData.parameters;

  let requestBodyName = "";
  if (!hasParams) {
    const requestBody = methodData.requestBody as RequestBodyObject;
    requestBodyName = Object.values(
      requestBody?.content?.["application/json"]?.schema ?? {},
    )?.[0]?.[0]
      ?.$ref?.split("/")
      .reverse()[0];
  } else {
    requestBodyName =
      endPointName.charAt(0).toUpperCase() +
      endPointName.slice(1) +
      "RequestModel";
  }
  // we must find the types for input and output of the query
  // and the respected name generated by the interface generator file
  // 200 response result interface  :

  const successResponseInterface = methodData.responses?.["200"].content?.[
    "application/json"
  ]?.schema?.$ref
    .split("/")
    .reverse()[0];

  const endPointText = `
${endPointName} : builder.${methodFinder(
    method,
  )}<${successResponseInterface ?? "void"}, ${requestBodyName ?? "void"}>({
  query: (data) => ({
    url: \`${endPoint}\`,
    method: "${method}",
    ${!hasParams ? "body : data" : "data"},
  }),
  ${methodFinder(method) === "query" ? "providesTags" : "invalidatesTags"} : ["${tag}"],
}),`;

  return {
    endPointText,
    endPointName,
    method,
    hasParams,
    methodData,
    description: descriptionText,
    responseInterface: successResponseInterface ?? null,
    requestInterface: requestBodyName ?? null,
  };
};

interface apiBuilderReturnType {
  apiFileText: string;
}
const apiBuilder = (
  data: OpenAPIObject,
  tag: string,
  baseUrl: string,
  skipEndpoints?: string[],
  interfaceAddress?: string,
): apiBuilderReturnType => {
  const filteredPathes = Object.entries(data?.paths!).filter(
    (item) => Object.values(item?.[1])?.[0].tags?.[0] === tag,
  );
  const endpoints = filteredPathes
    .filter((item) => {
      if (!!skipEndpoints) {
        return !skipEndpoints?.includes(item[0].split("/").reverse()?.[0]);
      } else {
        return true;
      }
    })
    .map((item) => endPointBuilder(item));
  const importedInterfaces = endpoints
    .map((item) => {
      return `${item.requestInterface ? item.requestInterface + "," : ""} ${item.responseInterface ? item.responseInterface + "," : ""}`;
    })
    .join(" ");
  let apiFileText = `import {
  createApi,
  fetchBaseQuery,
} from "@reduxjs/toolkit/dist/query/react";
import BaseUrlApi from "${baseUrl}";
import { RootState } from "redux/store";
import { ${importedInterfaces} } from "${interfaceAddress ?? "../interfaces"}";


export const ${tag}Api = createApi({
  reducerPath: "${tag}Api",
  baseQuery: fetchBaseQuery({ 
      baseUrl: BaseUrlApi,
      prepareHeaders: (headers, { getState }) => {
        headers.set("Access-Control-Allow-Origin", "*");
        headers.set("Access-Control-Allow-Headers", "*");
        headers.set("Access-Control-Allow-Methods", "POST , GET");
        let token = (getState() as RootState).auth.customerToken;

        if (token === "" && typeof window !== "undefined") {
          token = window.localStorage.getItem("customerToken")!;
        }
        headers.set("Authorization", 'Bearer token');
        return headers;
      },
  }),
  tagTypes: ["${tag}"],

  endpoints: (builder) => ({
      ${endpoints.map((item) => item.endPointText).join("\n")}
}),
}); 
  export const {
${endpoints
  .map((item) => {
    return (
      "use" +
      item.endPointName.charAt(0).toUpperCase() +
      item.endPointName.slice(1) +
      (methodFinder(item.method) === "query" ? "Query" : "Mutation")
    );
  })
  .join(",\n")} 
} = ${tag}Api;
`;
  return { apiFileText };
};

const generateApis = async (
  baseUrl: string,
  skipTags?: string[],
  skipEndpoints?: string[],
) => {
  const data = await readFile();
  const skipItems = skipEndpoints;
  const tags: string[] = [];
  Object.values(data?.paths!).forEach((item) => {
    const newTag = Object.values(item!)?.[0].tags?.[0];
    if (!!newTag) {
      if (tags.includes(newTag)) return;
      tags.push(newTag);
    } else {
      return;
    }
  });
  tags.forEach((tag) => {
    if (skipTags?.includes(tag)) return;
    const apiFileText = apiBuilder(data!, tag, baseUrl, skipItems!);
    fsPromise.writeFile(`./api/${tag}Api.ts`, apiFileText.apiFileText);
  });
};

async function main() {
  if (!process.argv) {
    console.error("please enter argumenst");
    return;
  }
  const args = process.argv?.slice(2);
  if (!args.includes("-baseUrl")) {
    console.error("please enter the base url");
    return;
  }
  const baseUrl = args[args.indexOf("-baseUrl") + 1];

  let skipEndpoints, skipTags;
  if (args.includes("-skipEndpoints")) {
    skipEndpoints = args[args.indexOf("-skipEndpoints") + 1].split(",");
  }
  if (args.includes("-skipTags")) {
    skipTags = args[args.indexOf("-skipTags") + 1].split(",");
  }
  generateApis(baseUrl, skipTags, skipEndpoints);
  // const data = await readFile();
  //
  // const skipItems = ["runMigrate"];
  // apiBuilder(data!, "car");

  // for (let item of Object.entries(data?.paths!)) {
  //   if (skipItems.includes(item[0].slice(1))) {
  //     continue;
  //   }
  //   endPointBuilder(item);
  // }
}

main();
